#include "idt.h"
#include "syscall.h"
/*
Random info to not forget:
    Exceptions are a type of interrupt generated by CPU when an error occurs - some will push a 32-bit error code on to the top of the stack which should get pulled from the stack before returning control to the currently running program.
    When CPU calls the interrupt handler, the CPU pushes these values onto the stack in this order -- EFLAGS -> CS -> EIP
*/

/* these create function pointers for rtc and keyboard handlers*/
int (*keyb_ptr)(void) = &linkage_keyboard_handler;
int (*rtc_ptr)(void) = &linkage_rtc_handler;
int (*pit_ptr)(void) = &linkage_pit_handler;
int (*syscall_ptr)(void) = &sys_call_handler;

/* this creates an array of exception function pointers */
typedef int (*except_ptr)(void);
except_ptr except_ptr_array[20] = {
 &exp_DE, &exp_DB, &exp_NMI, &exp_BP, &exp_OF, &exp_BR, &exp_UD, 
 &exp_NM, &exp_DF, &exp_R9, &exp_TS, &exp_NP, &exp_SS, &exp_GP, 
 &exp_PF, &exp_R15, &exp_MF, &exp_AC, &exp_MC, &exp_XF,
};

/* void init_idt(void)
 * Inputs: void
 * Return Value: void
 * Function: initialize IDT table */
void init_idt(){
    int idt_index;

    /* populate the exception vectors of the table */
    for (idt_index = 0x00; idt_index < 20; idt_index++){ // -- initializes the exceptions by making them trap gates
        idt[idt_index].reserved3 = 1; //should be 1 for trap gate
        idt[idt_index].reserved2 = 1;
        idt[idt_index].reserved1 = 1;
        idt[idt_index].size = 1;
        idt[idt_index].reserved0 = 0;
        idt[idt_index].present = 1;
        idt[idt_index].seg_selector = 0x0010;

        /* set exception vector to its corresponding vector slots */
        SET_IDT_ENTRY(idt[idt_index], except_ptr_array[idt_index]);

    }

    /* populate the keyboard and rtc interrupts of the table */
    for (idt_index = 0x20; idt_index <= 0x2F; idt_index++){ // -- initializes the interrupts by making them interrupt gates
        //DPL = 0, SEG_SELECTOR = 0x0010,  present = 1, size = 1 
        idt[idt_index].reserved3 = 0; //should be 0 for int gate
        idt[idt_index].reserved2 = 1;
        idt[idt_index].reserved1 = 1;
        idt[idt_index].size = 1;
        idt[idt_index].reserved0 = 0;
        idt[idt_index].present = 1;
        idt[idt_index].seg_selector = 0x0010;

        if (idt_index == PIC_OFFSET + PIT_IV)
            SET_IDT_ENTRY(idt[idt_index], pit_ptr);
        /* set the keyboard interrupt vector */
        if (idt_index == PIC_OFFSET + KEYBOARD_IV)
            SET_IDT_ENTRY(idt[idt_index], keyb_ptr);

        /* set the rtc interrupt vector */
        if (idt_index == PIC_OFFSET + RTC_IV) 
            SET_IDT_ENTRY(idt[idt_index], rtc_ptr);

    }

    /* populate the syscalls of the table */
    idt_index = 0x80; // -- initializes the interrupts by making them interrupt gates
    //DPL = 3, SEG_SELECTOR = 0x0010,  present = 1, size = 1 
    idt[idt_index].reserved3 = 1; //should be 1 for trap gate
    idt[idt_index].reserved2 = 1;
    idt[idt_index].reserved1 = 1;
    idt[idt_index].size = 1;
    idt[idt_index].reserved0 = 0;
    idt[idt_index].reserved4 = 0;
    idt[idt_index].present = 1;
    idt[idt_index].seg_selector = 0x0010;
    idt[idt_index].dpl = 3;

    /* set the keyboard interrupt vector */
    SET_IDT_ENTRY(idt[idt_index], syscall_ptr);
    
}

/* below are the exception functions, they all follow these general rule
 * Inputs: void
 * Return Value: int, 0 if successful
 * Function: handle the exception 
 */

/* division by zero*/
int exp_DE(){
    clear();
    printf("Exception Division Error\n");
    // while(1){}
    sys_halt(256);
    return 0;
}

/* RESERVED */
int exp_DB(){
    //clear();
    printf("Exception RESERVED");
    while(1){}
    return 0;
}

/* NMI */
int exp_NMI(){
    clear();
    printf("Exception NMI");
    while(1){}
    return 0;
}

/* breakpoint */
int exp_BP(){
    clear();
    printf("Exception breakpoint");
    while(1){}
    return 0;
}

/* overflow*/
int exp_OF(){
    clear();
    printf("Exception overflow");
    while(1){}
    return 0;
}

/* BOUND Range Exceeded*/
int exp_BR(){
    clear();
    printf("Exception BOUND Range Exceeded");
    while(1){}
    return 0;
}

/* Invalid Opcode*/
int exp_UD(){
    clear();
    printf("Exception Invalid Opcode");
    while(1){}
    return 0;
}

/* Device Not Available */
int exp_NM(){
    clear();
    printf("Exception Device Not Available");
    while(1){}
    return 0;
}

/*  Double Fault */
int exp_DF(){
    clear();
    printf("Exception Double Fault");
    while(1){}
    return 0;
}

/* Coprocessor Segment Overrun */
int exp_R9(){
    clear();
    printf("Exception Coprocessor Segment Overrun");
    while(1){}
    return 0;
}

/* Invalid TSS*/
int exp_TS() {
    clear();
    printf("Exception Invalid TSS");
    while(1){}
    return 0;
}

/* Segment Not Present*/
int exp_NP(){
    clear();
    printf("Exception Segment Not Present");
    while(1){}
    return 0;
}

/* Stack-Segment Fault*/
int exp_SS(){
    clear();
    printf("Exception Stack-Segment Fault");
    while(1){}
    return 0;
}

/*  General Protection*/
int exp_GP(){
    //clear();
    printf("Exception General Protection\n");
    //while(1){}
    sys_halt(256);

    return 0;
}

/* Page Fault*/
int exp_PF(){
    //printf("VALUE OF CR2 REGISTER IS: 0x%x\n",dump_contents()) ;
    //clear();
    printf("Exception Page Fault\n");
    //while(1){}
    sys_halt(256);
    return 0;
}

/* Intel Reserved*/
int exp_R15(){
    clear();
    printf("Exception Intel Reserved");
    while(1){}
    return 0;
}

/* x87 FPU FLoating POint Error*/
int exp_MF(){
    clear();
    printf("Exception x87 FPU FLoating POint Error");
    while(1){}
    return 0;
}

/* ALignment Check*/
int exp_AC(){
    clear();
    printf("Exception ALignment Check");
    while(1){}
    return 0;
}

/* Machine Check*/
int exp_MC(){
    clear();
    printf("Exception Machine Check");
    while(1){}
    return 0;
}

/* SIMD FLoating-Point Exception */
int exp_XF(){
    clear();
    printf("Exception SIMD FLoating-Point Exception");
    while(1){}
    return 0;
}
